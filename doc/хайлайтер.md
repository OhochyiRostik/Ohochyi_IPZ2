# Зміст
1. [Вступ](#вступ)
2. [Завдання](#завдання)
3. [Основні положення](#положення)
4. [Проектування](#проектування)
5. [Розробка](#розробка)
6. [Тестування](#тестування)
7. [Висновки](#висновки)
8. [Джерела](#джерела)

<a name="вступ"></a>
# Вступ

### Мета:

Даний документ ставить перед собою мету показати процес створення власного хайлайтера для обраної мови, а саме Data Processing Script, на базі бібліотеки highlight.js.


### Що таке Data Processing Script:

Data Processing Script - це спеціалізована мова, яка дозволяє описати послідовність дій, пов'язаних з обробкою даних в сервісі обробки, переклавши навантаження по реалізації рутинних обчислень на серверну сторону.

Скрипт являє собою безумовну послідовність команд, які виконуються на неявному контексті скрипта (результати попередніх команд - це контекст, з якого вибираються аргументи наступної команди).

У DPS можна використовувати ін'єкції html, text, xml, csv, json, які перетворюються в відповідні js-типи і об'єкти.


### Що таке Highlight.js:

Highlight.js - хайлайтер, написаний на JavaScript, працює як у браузері, так і на сервері, може працювати практично з будь-якою розміткою, не залежить від будь-яких інших фреймворків і має автоматичне визначення мови.


### Переваги підсвічування синтаксису:

Основною первагою підсвічування синтаксису є полегшення розпізнавання синтаксису і структури коду програмістом, це підтверджує дослідження, опубліковане на конференції PPIG, яке оцінило вплив виділення синтаксису на розуміння коротких програм, виявивши, що наявність підсвічування синтаксису значно скорочує час, необхідний програмісту для узагальнення семантики програми. Окрім того, дані, зібрані під час дослідження, що відстежували очі, свідчать про те, що підсвічування синтаксису дозволяє програмістам приділяти менше уваги стандартним синтаксичним компонентам, таким як ключові слова.

До плюсів хайлайтера можна також віднести той факт, що він допомагає зменшити кількість орфографічнох помилок або ж помилок друку в коді, наприклад неправильне написання ключових слів і т.д.

І звичайно не варто забувати про підвищення візуальної привабливості тексту, адже це відіграє також немаловажну роль.

<a name="завдання"></a>
# Завдання
### Загальне завдання:

Розробити модуль підсвітки синтаксису DPS з використанням бібліотеки highlight.js.

### Функціональність:

Користувач повинен мати можливість використовувати хайлайтер на власній машині та веб-сторінці.

<a name="положення"></a>
# Основні положення

Підсвітка синтаксису — виділення певним чином, певних елементів тексту, для покращення сприйняття його вмісту. Зазвичай застосовується до кодів програм, та розмітки документів. Розмітка синтаксису підтримується багатьма текстовими редакторами, та деякими сайтами, що публікують код.

## Highlight.js

Highlight.js - це супер DOM хайлайтер. Його ключовою особливстю є те що він намагається виявити мову програмування автоматично. Якщо автоматичне виявлення не працює, то ви можете вказати мову в атрибуті класу. Також highlight.js може працювати з багатомовним кодом.

**Ключові переваги highlight.js:**

  * [152 мови та 72 стилі](https://highlightjs.org/static/demo/)
  * автоматичне визначення мови
  * виділення багатомовного коду
  * доступно для node.js
  * працює з будь-якою розміткою
  * сумісний з будь-якою js-структурою

Щоб використовувати highlight.js у своєму проекті, просто включіть файли CSS та JS та ініціалізуйте за допомогою:

```javascript
initHighlightingOnLoad()
```
Метод:

```html
<!-- Include library -->
<link rel="stylesheet" href="/path/to/styles/default.css">
<script src="/path/to/highlight.pack.js"></script>
<!-- Initialize highlight -->
<script>hljs.initHighlightingOnLoad();</script>
```

Необхідна розмітка повинна виглядати так:

```html
<pre><code class="html">Sample 2021 code for the bois</code></pre>
```
Приклад роботи highlight.js:

![alt text](https://github.com/OhochyiRostik/Ohochyi_IPZ2/blob/main/Images/Image5.png)

## Prism.js

Prism - це легкий, розширюваний підсвічувач синтаксису, побудований з урахуванням сучасних веб-стандартів. Він використовується на мільйонах веб-сайтів, у тому числі на тих, які ви відвідуєте щодня. На даний момент Prism підтримує 257 мов. Щоб  розширити функціональність Prism, можна користуватися плагінами. Плагіни - це додаткові скрипти (і CSS-код). Для їх використання просто виберіть їх на сторінці завантаження.

### Основне використання

Вам потрібно буде включити завантажені на вашу сторінку prism.css та prism.js файли. 

Приклад:
```html
<!DOCTYPE html>
<html>
<head>
	...
	<link href="themes/prism.css" rel="stylesheet" />
</head>
<body>
	...
	<script src="prism.js"></script>
</body>
</html>
```
Призм робить все можливе, щоб заохочувати належні авторські практики. Тому він працює лише з елементами, оскільки розмітка коду без елемента є семантично недійсною. Відповідно до специфікації HTML5 , рекомендованим способом визначення мови коду є клас, який і використовує Prism. Крім того , Призм також підтримує більш короткий варіант: 

`<code><code>language-xxxxlang-xxxx`

Рекомендований спосіб розмітки блоку коду (як для семантики і для Prism) являє собою елемент з елементом всередині, наприклад , так: `<pre><code>`

Приклад:
`<pre><code class="language-css">p { color: red }</code></pre>`

Якщо ви використовуєте цей шаблон, файл автоматично отримає клас (якщо його ще немає) і буде стилізований як блок коду `<pre>language-xxxx`

Вбудовані фрагменти коду виконуються так:

`<code class="language-css">p { color: red }</code>`

### Мовне успадкування

Щоб полегшити ситуацію, Призм вважає, що клас мови успадковується. Отже, якщо кілька елементів мають однакову мову, ви можете додати клас до одного із їхніх спільних предків. Таким чином, ви також можете визначити мову за замовчуванням для всього документа, додавши клас до елемента або `<code>language-xxxxlanguage-xxxx<body><html>`

Якщо ви хочете відмовитись від виділення елемента, який успадковує його мову, ви можете додати до нього клас. Мова також може бути успадкована, щоб відключити підсвічування для елемента з класом і всіх його нащадків: `<code>language-nonenone`

Якщо ви хочете відмовитись від виділення, але все одно використовувати такі плагіни, як 'Показати невидимі', то додайте language-plain.

### Підсвічування вручну

Якщо ви хочете, щоб будь-які елементи не підсвічувались автоматично, а замість цього використовували API , ви можете встановити значення до запуску події. Встановивши атрибут на елемент, що містить ядро Prism, це буде зроблено автоматично. Приклад: `Prism.manualtrueDOMContentLoadeddata-manual<script>`

`<script src="prism.js" data-manual></script>`

або

```html
<script>
window.Prism = window.Prism || {};
window.Prism.manual = true;
</script>
<script src="prism.js"></script>
```

### Використання з CND

У поєднанні з CDN рекомендуєnmcz використовувати плагін Autoloader, який автоматично завантажує мови, коли це необхідно.

Налаштування автозавантажувача буде виглядати наступним чином. Ви також можете додати власні теми:

```html
<!DOCTYPE html>
<html>
<head>
	...
	<link href="https://{{cdn}}/prism@v1.x/themes/prism.css" rel="stylesheet" />
</head>
<body>
	...
	<script src="https://{{cdn}}/prism@v1.x/components/prism-core.min.js"></script>
	<script src="https://{{cdn}}/prism@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
```
Зверніть увагу, що посилання у наведеному вище зразку коду служать заповнювачами. Вам доведеться замінити їх дійсними посиланнями на CDN на ваш вибір.

CDN, що надають PrismJS, наприклад, cdnjs , jsDelivr та UNPKG .

### Використання з Webpack, Browserify та іншими пакетами:

Якщо ви хочете використовувати Prism із пакетом, встановіть Prism за допомогою npm:

`$ npm install prismjs`

Потім ви можете використати import, щоб увійти до набору:

`import Prism from 'prismjs';`

Щоб спростити налаштування вашого екземпляру Prism на потрібні вам мови та плагіни, використовуйте плагін babel , babel-plugin-prismjs. Це дозволить завантажити мінімальну кількість мов та плагінів, щоб задовольнити ваші потреби.

### Використання з NODE

Якщо ви хочете використовувати Prism на сервері або через командний рядок, то вам варто знати, що Prism можна використовувати з Node.js. Це може бути корисно, якщо ви намагаєтеся генерувати статичні HTML-сторінки з виділеним кодом для середовищ, які не підтримують JS на стороні браузера, як-от сторінки AMP .

Приклад:
```html
const Prism = require('prismjs');

// The code snippet you want to highlight, as a string
const code = `var data = 1;`;

// Returns a highlighted HTML string
const html = Prism.highlight(code, Prism.languages.javascript, 'javascript');
```
Так prism.js буде завантажувати мови за замовчуванням: markup, css, clikeі javascript. Ви можете завантажити більше мов за допомогою утиліти, яка автоматично обробляє всі необхідні залежності: loadLanguages()

Приклад:
```html
const Prism = require('prismjs');
const loadLanguages = require('prismjs/components/');
loadLanguages(['haml']);

// The code snippet you want to highlight, as a string
const code = `= ['hi', 'there', 'reader!'].join " "`;

// Returns a highlighted HTML string
const html = Prism.highlight(code, Prism.languages.haml, 'haml');
```

*Примітка* : Не використовуйте loadLanguages () з Webpack або іншим Bundler, так як це змусить включити до Webpack всі мови і плагін.

*Примітка* : loadLanguages () буде ігнорувати невідомі мови та реєструвати попереджувальні повідомлення на консолі. Ви можете запобігти попередженням, встановивши `loadLanguages.silent = true.`









### Повний перелік функцій

-Тільки 2 КБ мініфікованих та зібраних у ZIP-файл (ядро). Кожне визначення мови додає приблизно 300-500 байт.

-Заохочує належну авторську практику. Інші маркери заохочують або навіть змушують вас використовувати елементи, які є семантично помилковими, наприклад `<pre>` (самостійно) або `<script>`. Призм змушує використовувати правильний елемент для розмітки коду: `<code>`. Самостійно для вбудованого коду або всередині `<pre>` для блоків коду. Крім того, мова визначається способом, рекомендованим у проекті HTML5: через клас language-xxxx.

-Клас language-xxxx успадковується. Це означає, що якщо кілька фрагментів коду мають однакову мову, ви можете просто визначити його один раз, в одному із їхніх загальних предків.
-Підтримує паралелізм із веб-працівниками, якщо такий є. Вимкнено за замовчуванням.

-Дуже легко розширити, не змінюючи код, завдяки архітектурі плагінів Prism. Кілька гачків розкидані по всьому джерелу.

-Дуже легко визначити нові мови. Єдине, що вам потрібно - це добре розуміння регулярних виразів.

-Усі стилі виконуються за допомогою CSS, з розумними назвами класів.

-Широка підтримка браузерів: Edge, IE11, Firefox, Chrome, Safari, Opera, більшість мобільних браузерів.

-Виділяє вбудовані мови (наприклад, CSS всередині HTML, JavaScript всередині HTML).

-Також виділяється вбудований код, а не лише блоки коду.

-Це не змушує вас використовувати будь-яку розмітку, призначену для призм, лише стандартну розмітку, яку ви все одно повинні використовувати. Отже, ви можете просто спробувати призм  на деякий час, і видалити, якщо вам не подобається.

-Виділяє конкретні рядки та / або діапазони рядків (потрібен плагін).

-Показує невидимі символи, такі як вкладки, розриви рядків тощо (потрібен плагін).

-Автоматично посилається на URL-адреси та електронні листи, використовувати посилання Markdown у коментарях (потрібен плагін).

### Обмеження

-Будь-який існуючий HTML-код у коді буде видалено. Однак є способи обійти це .

-На основі регулярного виразу, *will* він може вийти з ладу у певних випадках, які описані на сторінці відомих помилок .

-Деякі теми мають проблеми з певними макетами. Відомі випадки є задокументовані.

-Немає підтримки IE 6-10. Якщо хтось може читати код, він, мабуть, серед 95% населення із сучасним браузером.

<a name="проектування"></a>
# Проектування

**Сценарій підсвітки тексту типу string**

| Ідентифікатор: | STRING |
| --- | --- |
| Назва: | Підсвітка тексту типу string |
| Учасники: | Користувач; Система |
| Передумови: | Користувач використав елементи виділенні лапками |
| Результат: | Користувач отримує певну підсвітку синтаксису |
| Виключні ситуації: | Текст знаходиться в середині коментаря |
| Основний сценарій: | 1. Користувач використовує текст виділений лапками.<br>2. Система ідентифікує даний текст окремим класом.<br>3. Система підсвічує даний текст певним кольором.<br>4. Користувач отримує певну підсвітку синтаксису.|

**Сценарій підсвітки коментарів**

| Ідентифікатор: | COMMENT |
| --- | --- |
| Назва: | Підсвітка коментарів |
| Участники: | Користувач; Система |
| Передумови: | Користувач використав елементи виділенні данним чином: // |
| Результат: | Користувач отримує певну підсвітку синтаксису |
| Виключні ситуації: | Символи '//' і подальший текст є 'string' класом |
| Основний сценарій: |  1. Користувач вписав текст після //.<br>2. Система ідентифікує даний текст окремим класом.<br>3. Система підсвічує даний текст певним кольором.<br>4. Користувач отримує певну підсвітку синтаксису.|

**Сценарій підсвітки розділових символів**

| Ідентифікатор: | SYMBOL |
| --- | --- |
| Назва: | Підсвітка розділових символів |
| Участники: | Користувач; Система |
| Передумови: | Користувач використав розділовий символ |
| Результат: | Користувач отримує певну підсвітку синтаксису |
| Виключні ситуації: | Текст знаходиться в середині коментаря, або ж є 'string' класом |
| Основний сценарій: |  1. Користувач використав розділовий символ.<br>2. Система ідентифікує даний текст окремим класом.<br>3. Система підсвічує даний текст певним кольором.<br>4. Користувач отримує певну підсвітку синтаксису.|

**Сценарій підсвітки слів-команд**

| Ідентифікатор: | TITLE |
| --- | --- |
| Назва: | Підсвітка команди |
| Участники: | Користувач; Система |
| Передумови: | Користувач використав 'ddl.', 'dml.', 'c.', 's.', 'services.'  |
| Результат: | Користувач отримує певну підсвітку синтаксису |
| Виключні ситуації: | Текст знаходиться в середині коментаря, або ж є 'string' класом |
| Основний сценарій: |  1. Користувач використав слова-команди.<br>2. Система ідентифікує даний текст окремим класом.<br>3. Система підсвічує даний текст певним кольором.<br>4. Користувач отримує певну підсвітку синтаксису.|



<a name="розробка"></a>
# Розробка

Розробка і подальше написання власного хайлайтера починається з розуміння структури та базового синтаксису мови програмування для якої власне і створюється хайлайтер.
Для початку потрібно розуміти, що будь-яка мова програмування, для якої ви будете створювати хайлайтер, складається з багатьох умовних частин. Такими частинами у більшості мов програмування виступають: 

	* ключові слова
	* коментарі
	* функції (процедури)
	* символи
	* класи та типи об'єктів та безліч інших складових коду

Ключовою особливістю саме DPS є інєкції html, text, xml, csv, json, що значною мірою підвищує складність завдання.


У Highlight.js колір тексту задається "режимом підсвітки". Кожен режим підсвітки може складатися з:

	* умови початку
	* умови закінчення
	* списку вміщених підрежимів
	* правил, регулярних виразів та ключових слів
	* інколи може містити деяку мову всередині іншої мови

Надалі розглядатимемо загальну структуру хайлайтеру highlight.js та її найважливіші складові:
```javascript
{
  case_insensitive: true, // чутливість до регістру
  keywords: 'for if while',
  contains: [
    {
      className: 'string',
      begin: '"', 
      end: '"'
    },
    hljs.COMMENT(
      '/\\*', // умова початку
      '\\*/', // умова кінця
      {
        contains: [
          {
            className: 'doc', 
	    begin: '@\\w+'
          }
        ]
      }
    )
  ]
}
```
### Ключові слова (Keywords)

У загальному випадку ключове слово – це засіб мови програмування, який вбудований в мову програмування і використовується для розробки програм на цій мові. Варто зазаначити, що багато мов мають деякі спільні ключові слова, так наприклад ключове слово 'for' використовується в Python, С, Java.  

Бібліотека Highlight.js дозволяє задавати перелік ключових слів декількома способами:

-списком через пробіл

-масивом

```javascript
{
  keywords: {
    keyword: 'else for if while', //Перший спосіб задання списку ключових слів - перелік у лапках через пробіл 
    literal: ['false','true','null'], //Другий спосіб - масивом.
    _relevance_only: 'one two three four'
  }
}
```

### Генерація підсвітки
Важливий той факт, що колір яким буде підсвічуватися текст ми не задаємо, ми лише вказуємо де міжі коментарів, межі тексту типу 'string', де ключові слова, а колір яким буде підсвічуватися даний текст визначає 'css' стиль, у бібліотеці highlight.js представлено безліч таких. В даному хайлайтері використано cтиль 'monokai-sublime'.

Для прикладу порівняння, як 'css' стиль змінює хайлайтер:

| Приклад 1: monokai-sublime | Приклад 2: srcery |
| --- | --- |
| ![Image alt](https://github.com/OhochyiRostik/Ohochyi_IPZ2/blob/main/Images/Image3.png) | ![Image alt](https://github.com/OhochyiRostik/Ohochyi_IPZ2/blob/main/Images/Image4.png) |


Атрибут `className` задає тип і відповідно колір підсвічуємого тексту, ось декілька аргументів, які можна сюди передавати:

	* "string"
	* "comment"
	* "variable"
	* "symbol"
	* "number"
	* "title"

```javascript
{
className:"symbol",
begin: /:|;|\.|&&|!|==|=>|<=|{|}|\(|\)|\[|\]|,|=|\|\||\$|`|\?>|<\?|<|>|\//,
}
```
Як видно з даного прикладу немаловажну роль у написанні хайлайтера відіграють регулярні вирази, адже саме за допомогою них задаються умови початку і кінця підсвічування синтаксису. 

Чудовими сайтами для їх вивчення та тренування відповідно є: [MND Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions) та [Regexr](https://regexr.com/)

Давайте розглянемо регулярні вирази у наведеному вище прикладі:
Даний клас має виділяти різні символи в коді.
Вертикальна риса `|` позначатиме логічну дію 'OR'. Перед деякими символами також вставлено `\` - це символ екранації. Умовою кінця є опціональною, в даному випадку вона відсутня.


<a name="тестування"></a>
# Тестування
Упроцесі розробки, тестування коду відбувалося на локальній веб-сторінці, оскільки це дуже зручно і можна в рельному часі спостерігати роботу коду. 
Код веб-сторінки якою я користувався при написанні хайлайтера:

```html
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/monokai-sublime.min.css">
	<title>Хайлайтер</title>
</head>
<body>
<!-- srcery -->
<!-- monokai-sublime -->
<!-- qtcreator_dark -->
	<pre>
	<code class="dps">
set("response")

&lt;?html

    &lt;div class="ma-1" style="border:2px solid #dedede">
    &lt;div class="success--text mx-3 pa-2">
        &lt;div class="row display-1 d-flex justify-center">
            &lt;div class="align-center pa-0">
                &lt;i class="mdi mdi-airplane"></i>
                ${value}
            &lt;/div>
        &lt;/div>
        &lt;div class="pa-0 d-flex justify-center body-2">
            Successed
        &lt;/div>
    &lt;/div>
    &lt;/div>

?>

set("template")

&lt;?javascript
    $scope.res = _.template($scope.template)
                        ({value: $scope.response})
?>
return("res")
html()


ddl.drop("foresight_UA")
&lt;? javascript
    $scope.swotResultModel = [{
        "identity": "swot_sectors",
        "schema": "foresight_UA",
        "attributes": {
            "tag":"string",
            "data": {
                "type": "json"
            }
        }
    }];
?>   

ddl.create(model:{{swotResultModel}})


// получить информацию о версии DPS
version()
// $scope.head содержит информацию про версию
// {
//     "name": "DJ Data Processing Script",
//     "version": "0.1.1",
// получить информацию о версии DPSversion()
// $scope.head содержит информацию про версию// {
//     "name": "DJ Data Processing Script",
//     "version": "0.1.1",
//     "commands": "@all, @any, ..."
// }
// $scope.version <- $scope.head.version
set(var:"version",value:"version")
// $scope.head
// 
// $scope.head <- $scope.version
get("version")
// Typecasting $scope.head  to string
text()


// version()
ver()
// set(var:"version")
set("version")
// get(var:"version.version")
get("version.version")
text()




	</code>
	</pre>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
	<script type="text/javascript" src="C:\Users\User\Desktop\Хайлайтер\test.min.js"></script>
	<script type="text/javascript">hljs.highlightAll();</script>


</body>
</html>
```

Розглянемо детальніше даний код.
```html
	</pre>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
	<script type="text/javascript" src="C:\Users\User\Desktop\Хайлайтер\test.min.js"></script>
	<script type="text/javascript">hljs.highlightAll();</script>
```
Дані рядки відповідають за підключення highlight.js та самого хайлайтера, як видно, модуль підключається за допомогою посилання, а для підключення хайлайтера, вказано шлях до його розташування на комп'ютері.
```html
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/monokai-sublime.min.css">
```
У цьому ж рядку ми вибираємо css стиль, в якому буде оформлений хайлайтер. Більш детально про ці стилі написано в пункті "Розробка".

Між рядками `<code class="dps">` і `</code>`, вписуємо 'піддослідний' код.

Для безпосереднього тестування було використано стандартні тести з бібліотеки highlight.js. 

Але перед тим, як розпочати безпосереднє тестування, необхідно налаштувати середовище, а саме встановити Noge.js. Для завантаження можна перейти за посиланням:https://nodejs.org/uk/. 

Перевірити чи завантажений Node.js та npm і дізнатись їх версію можна у консолі за допомогою команд:

`node -v`
`npm -v`

Далі необхідно в папку \highlight.js\src\languages помістити код хайлайтера, потім командою `npm i` завантажуємо до нашого каталогу проекту `npm`. 

Вписуємо в консоль команду `node tools/build.js -n dps -t node`, дана команда запускає побудову середовища тестування.

Якщо все зроблено правильно, то консоль видасть наступне:
![Image alt](https://github.com/{username}/{repository}/raw/{branch}/{path}/image.png)

Тоді вбиваємо в консоль `npm test`, дана команда запускає тестування.

Після успішного тестування консоль покаже наступне:
![Image alt](https://github.com/{username}/{repository}/raw/{branch}/{path}/image.png)
![Image alt](https://github.com/{username}/{repository}/raw/{branch}/{path}/image.png)
<a name="висновки"></a>
# Висновки
Провівши аналіз предметної області, порівнявши переваги та недоліки вже існуючих систем підсвічування синтаксису, враховуючи навчальну направленість проекту, було прийнято рішення створити власний хайлайтер для обраної мови Data Processing Script на базі бібліотеки highlight.js.

<a name="джерела"></a>
# Джерела

https://prismjs.com/

https://highlightjs.org/

https://en.wikipedia.org/wiki/Syntax_highlighting

https://mochajs.org/

https://jace-dev.herokuapp.com/design/About%20JACE#/dps

https://highlightjs.readthedocs.io/en/latest/language-guide.html#

https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_Expressions

https://github.com/highlightjs/highlight.js/blob/main/extra/3RD_PARTY_QUICK_START.md

https://github.com/highlightjs/highlightjs-cypher

https://github.com/highlightjs/highlight.js

https://github.com/highlightjs/highlightjs-robots-txt

https://github.com/boldak/jace-mark

